### 1003 我要通过！

得到“答案正确”的条件是：

1.字符串中必须仅仅含有PAT这三种字符，不可以包含其他字符

2.形如xPATx的字符串都可以获得答案正确，其中x是空字符串或者<u>仅由字母A组成的字符串</u>。

​                                                                                                                           A,AA,AAA...

3.如果aPbTc是正确的，那么aPbATca也是正确的，其中abc均是空串或者仅有字母A组成的字符串。

> 条件一好理解，主要是针对二三两点的理解。
>
> 条件二就是在PAT前后加上等量的A，可以通过。
>
> 条件三 思考过程如下：
>
> > 如果<u>&nbsp;PAT&nbsp;</u>是正确的，那么 <u>&nbsp;PAAT&nbsp;</u> 是正确的,其中ac是空格。
>
> > 如果<u>APATA</u>是正确的，那么<u>APAATAA</u>是正确的。
>
> > 如果AAPATAA是正确的，那么AAPAATAAAA是正确的
>
> 可以得出只能有一个P和一个T，中间开头结尾可以加入A，但是加入A的数量必须满足 首A*中间A=尾A

```c++
关键代码
//m是字符和该字符出现次数的映射
m['A'] == 1 && m['A'] != 0 && m['T'] == 1  //只能有一个P和一个T并且必须有A
m.size() == 3 //m映射的大小为3，即只有PAT三种字符
t - p != 1 && p * (t - p - 1) == s.length() - t - 1 //首A*中间A=尾A
//p是'P‘的位置，就是首A，t是'T'的位置，表示到'T'为止字符的个数，(t - p - 1)是中间A，
```



### 1005 继续（3n+1）猜想

当验证卡拉兹猜想（遇到偶数，除以2；遇到奇数，奇数的三倍加一除以二，最后会得到一）的时候，为了避免重复计算，可以给出一个关键数字。

例如 计算3的时候 需要计算3，5，8，4，2，1 在这整个数列中3是关键数字。

1005题的目的是找出数列中的关键数字，并且按降序输出。

**对每个输入的数字n进行验证，把验证过的数字对应的arr标记为1，然后对输入的数字从大到小排列，输出arr标记为0的数字**

> 也就是不在已验证之列的数字，不明白为什么输出这些数字，也许不在已验证之列就说明验证这个数字需要经过其他数字？



### 1007 素数对

找出小于N的素数中，相邻之差为2的素数对个数。

```c++
for(i = 5; i < n; i++)
{
    if(isprime(i-2) && isprime(i))count++;
}
//只需要判断相邻的奇数是否都是素数即可
```



### 1010 多项式求导

flag是输出标志，判断是否已经有过输出。

直接判断b（x的指数）可以将输出结果分为两类：Ⅰ零多项式 输出 0 0；Ⅱ 非零多项式 正常计算



### 1013  数素数

多次运行超时，最终确定是判断素数的算法，时间复杂度过高。

`用的 i <= n/2 判断，最好用i * i <= n判断。`



### 1014 福尔摩斯的暗号

#include<cctype> 有 isdigit()判断字符串是否数字，isalpha()判断是否是字母（包括大小写）



### 1015 德才论

N考生数 L最低录取分 H优先录取线

考号 德分 才分

Ⅰ 德分才分均高于H，按总分高到低排序

Ⅱ 德分高于H，才分不及，按总分

Ⅲ 德才分低于H，但德分不低于才分

Ⅳ 达到L

输出 M（录取的学生）以及所有录取考生的信息

**要点：1.结构体存储 2.cmp函数 先按总分排序，再按德分排序，最后按才分排序**

```c++
struct stu
{
    int id,ds,cs;
}

bool cmp(struct stu a,struct stu b)
{
    if((a.ds + a.cs) != (b.ds + b.cs))
    	return (a.ds+a.cs) > (b.ds + b.cs);
    else if(a.ds != b.ds)
    	return a.ds > b.ds;
    else 
        return a.id < b.id;    
}
```

