### 算法学习开端
其实是从软考复习那边过来的。之前备考PAT的时候也有打算看过算法导论，后来在陈越版的数据结构跟算法导论之间来回横跳，两本都没能看进去多少。
跳过了第一章节，打算从第二章节开始学习。

#### 2.1-1 说明插入排序在给定集合A上面的执行过程
其实就是从把第一个元素当成有序集合开始，不断将后面的数字插入有序集合当中。


#### 2.1-2 写出非升序排序的伪代码
```
//非升序伪代码
INSERTION-SORT（A）
for j=2 to A.length
  key = A[i]
  i = j-1
  while i > 0 and A[i] < key
    A[i+1] = A[i]
    i = i-1
  A[i+1]=key
```


#### 2.1-3 考虑查找问题，写出线性查找的伪代码
```
输入：n个数的一个序列A={a1,a2,...,an}和一个值v
输出：下标i使得v=a[i]或者当v不在A中出现时，v为特殊值NIL
```
- 解答
```
查找问题伪代码
FINDITEM(V,A)
flag = 0
for i = 1 to A.length
  if A[i] != v
    continue
  else
    print i
    flag = 1
if flag = 0
  v = NIL    
```
还要使用一个循环不变式来证明算法的正确性。     
看了半天没明白循环不变式的三个条件是怎么取得，但是大概能懂：   
第一个条件是说循环的入口：初始化值；第二个条件是说循环中的特定处理过程；第三个条件是说循环的终止条件也就是出口   
按照这样的理解：
查找算法的初始化：i=1此时循环一次 A[i]与v相等则输出1 不等则改变v值 保持：当flag=0时，持续判断A[i]与v是否相等 终止：flag = 1 就终止程序


#### 2.1-4 考虑把两个n位二进制整数相加，这两个整数分别存储在两个n元数组A和B中，这两个整数的和应该按二进制形式存储在一个n+1元数组C中
```
reverse A,B
tmp = 0//进位
while i < n
  C[i] = (tmp + A[i] + B[i]) % 2
  tmp = (tmp + A[i] + B[i]) / 2
  
 reverse C
```

